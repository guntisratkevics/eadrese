"""eadrese_client.py
~~~~~~~~~~~~~~~~~~~
A **reference implementation** of Latvia's e‑adrese (VRAA VUS) integration in pure Python.
-------------------------------------------------------------------------

This file is **framework‑agnostic** – you can:
* import it directly in any Python project, **or**
* embed it in an Odoo addon, calling the public methods from cron jobs / button actions.

Dependencies (install with pip):
```
pip install zeep requests cryptography python-dateutil
```

> **NOTE**  
> The real service requires a qualified website authentication certificate (QWAC) *and* a qualified e‑seal (QSeal).  
> For local tests leave ``certificate=None`` + ``private_key=None``; VUS will still accept the call inside the **DIV** sandbox.
"""
from __future__ import annotations

import base64
import datetime as _dt
import logging
import uuid
from dataclasses import dataclass
from pathlib import Path
from typing import Iterable, List, Mapping, Optional, Tuple

import requests
from dateutil import tz
from zeep import Client  # SOAP
from zeep.helpers import serialize_object
from zeep.plugins import HistoryPlugin
from zeep.transports import Transport
from zeep.wsse.signature import Signature


__all__ = [
    "EAddressConfig",
    "Attachment",
    "EAddressClient",
    "EAddressError",
]

logger = logging.getLogger(__name__)
logger.setLevel(logging.INFO)

# ---------------------------------------------------------------------------
# Data models
# ---------------------------------------------------------------------------


@dataclass
class EAddressConfig:
    """Credentials and endpoints for e‑adrese VUS/DIV.

    Args:
        client_id: Supplied by VDAA when you register the system.
        client_secret: For OAuth2 *Client Credentials* flow.
        certificate: Path to QWAC certificate in *PEM* (or `None` in DIV test).
        private_key: Path to private key matching the certificate (PEM).
        wsdl_url: UnifiedService WSDL address (sandbox by default).
        token_url: OAuth2 token endpoint (sandbox by default).
        verify_ssl: Verify server SSL certs (turn *off* for first quick tests).
    """

    client_id: str
    client_secret: str
    certificate: Optional[Path] = None
    private_key: Optional[Path] = None
    wsdl_url: str = "https://div.vraa.gov.lv/UnifiedService.svc?wsdl"
    token_url: str = "https://div.vraa.gov.lv/Auth/token"
    verify_ssl: bool = True


@dataclass
class Attachment:
    """File to include in an e‑adrese message."""

    filename: str
    content: bytes
    content_type: str = "application/octet-stream"

    @classmethod
    def from_file(cls, path: Path, content_type: Optional[str] = None) -> "Attachment":
        data = path.read_bytes()
        ctype = content_type or _guess_mime(path.suffix)
        return cls(filename=path.name, content=data, content_type=ctype)


class EAddressError(RuntimeError):
    """Raised for any VUS error or transport problem."""

    def __init__(self, msg: str, *, response: Optional[Mapping] = None):
        super().__init__(msg)
        self.response = response


# ---------------------------------------------------------------------------
# Helpers
# ---------------------------------------------------------------------------


_MIME_MAP = {
    ".xml": "application/xml",
    ".pdf": "application/pdf",
    ".txt": "text/plain",
}


def _guess_mime(ext: str) -> str:
    return _MIME_MAP.get(ext.lower(), "application/octet-stream")


def _tz_riga() -> _dt.tzinfo:
    return tz.gettz("Europe/Riga")


# ---------------------------------------------------------------------------
# Main client
# ---------------------------------------------------------------------------


class EAddressClient:
    """Thin wrapper around e‑adrese VUS (SOAP) + OAuth2 auth."""

    def __init__(self, cfg: EAddressConfig):
        self.cfg = cfg
        self._session = requests.Session()
        if not cfg.verify_ssl:
            self._session.verify = False  # noqa: S501 (only for sandbox)
        self._token: Optional[str] = None
        self._token_expiry: _dt.datetime | None = None

        self._history = HistoryPlugin()
        transport = Transport(session=self._session, timeout=30)
        wsse = None
        if cfg.certificate and cfg.private_key:
            wsse = Signature(str(cfg.certificate), str(cfg.private_key))

        self._client = Client(cfg.wsdl_url, transport=transport, plugins=[self._history], wsse=wsse)
        self._svc = self._client.create_service(
            "{http://vraa.gov.lv}IUnifiedService",
            cfg.wsdl_url.replace("?wsdl", ""),
        )
        logger.info("Initialized e‑adrese SOAP client @ %s", cfg.wsdl_url)

    # ---------------------------------------------------------------------
    # Public API
    # ---------------------------------------------------------------------

    def send_message(
        self,
        recipient_personal_code: str,
        *,
        document_kind_code: str = "EINVOICE",
        subject: str = "Elektroniskais rēķins",
        body_text: str = "Lūdzu, skatiet pielikumā e‑rēķinu.",
        attachments: Iterable[Attachment],
    ) -> str:
        """Send a *single* e‑adrese message.

        Returns the **messageId** assigned by VUS. Raises :class:`EAddressError`
        on failure.
        """
        token = self._get_token()
        envelope = self._build_envelope(
            recipient_personal_code,
            document_kind_code,
            subject,
            body_text,
            list(attachments),
        )
        logger.debug("Built envelope: %s", envelope)
        try:
            response = self._svc.SendMessage(
                OAuthToken=token,
                Message=envelope,
            )
        except Exception as exc:  # noqa: BLE001
            # Capture last request/response for easier debugging
            last_sent = self._history.last_sent
            last_received = self._history.last_received
            logger.exception("SOAP fault while sending message")
            raise EAddressError("SOAP fault: %s" % exc) from exc

        res = serialize_object(response)
        if not res.get("IsSuccess"):
            raise EAddressError("VUS error", response=res)
        return res["MessageID"]

    def get_notifications(self) -> List[Mapping]:
        """Pull notifications (new messages, delivery receipts, etc.)."""
        token = self._get_token()
        try:
            resp = self._svc.GetNotifications(OAuthToken=token)
        except Exception as exc:  # noqa: BLE001
            raise EAddressError("SOAP fault while pulling notifications") from exc
        return serialize_object(resp).get("NotificationList", [])

    # ------------------------------------------------------------------
    # Internal helpers
    # ------------------------------------------------------------------

    def _get_token(self) -> str:
        now = _dt.datetime.now(tz=_tz_riga())
        if self._token and self._token_expiry and now < self._token_expiry - _dt.timedelta(seconds=60):
            return self._token
        logger.debug("Fetching new OAuth token…")
        resp = self._session.post(
            self.cfg.token_url,
            data={
                "grant_type": "client_credentials",
                "client_id": self.cfg.client_id,
                "client_secret": self.cfg.client_secret,
            },
            timeout=15,
        )
        if resp.status_code != 200:
            raise EAddressError(f"OAuth failed: {resp.text}")
        data = resp.json()
        self._token = data["access_token"]
        self._token_expiry = now + _dt.timedelta(seconds=data.get("expires_in", 3600))
        return self._token

    def _build_envelope(
        self,
        recipient_code: str,
        kind_code: str,
        subject: str,
        body_text: str,
        attachments: List[Attachment],
    ) -> Mapping:
        # Attachment conversion ------------------------------------------------
        files = []
        for att in attachments:
            enc = base64.b64encode(att.content).decode()
            files.append(
                {
                    "AttachmentID": str(uuid.uuid4()),
                    "FileExtension": Path(att.filename).suffix.lstrip("."),
                    "FileName": att.filename,
                    "MimeType": att.content_type,
                    "FileData": enc,
                }
            )

        # Envelope ------------------------------------------------------------
        msg = {
            "Header": {
                "SenderID": self.cfg.client_id,
                "RecipientID": recipient_code,
                "DocumentKindCode": kind_code,  # <- "EINVOICE" for e‑rēķini
                "CreationDate": _dt.datetime.now(tz=_tz_riga()).isoformat(),
                "Subject": subject,
            },
            "Body": {
                "ContentText": body_text,
                "Attachments": {"Attachment": files},
            },
        }
        return msg


# ---------------------------------------------------------------------------
# Script usage example
# ---------------------------------------------------------------------------

if __name__ == "__main__":
    import os

    logging.basicConfig(level=logging.DEBUG)

    cfg = EAddressConfig(
        client_id=os.getenv("EADR_CLIENT_ID", "demo-client"),
        client_secret=os.getenv("EADR_CLIENT_SECRET", "demo-secret"),
        verify_ssl=False,  # DIV sandbox often has self‑signed certs
    )
    client = EAddressClient(cfg)

    xml_path = Path("sample_invoice.xml")  # PREPARE YOUR OWN TEST FILES
    pdf_path = Path("sample_invoice.pdf")
    if not xml_path.exists() or not pdf_path.exists():
        logger.error("Please put sample_invoice.xml + .pdf next to this script before running.")
        exit(1)

    msg_id = client.send_message(
        recipient_personal_code="010170-12345",  # test recipient in DIV
        attachments=[
            Attachment.from_file(xml_path, "application/xml"),
            Attachment.from_file(pdf_path, "application/pdf"),
        ],
    )
    print("Message successfully sent. ID:", msg_id)

    # Fetch notifications (optional)
    notes = client.get_notifications()
    print("Notifications:", notes)
